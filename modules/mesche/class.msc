(define-module (mesche class)
  (import (mesche array)
          (mesche string)))

;; This implementation is based on Tiny CLOS by Gregor Kiczales:
;; https://github.com/kstephens/tinyclos/blob/master/tiny-clos.scm
;;
;; Thus, I must include this hideous copyright notice:
;; **********************************************************************
;; Copyright (c) 1992 Xerox Corporation.
;; All Rights Reserved.
;;
;; Use, reproduction, and preparation of derivative works are permitted.
;; Any copy of this software or of any derivative work must include the
;; above copyright notice of Xerox Corporation, this paragraph and the
;; one after it.  Any distribution of this software or derivative works
;; must comply with all applicable United States export control laws.
;;
;; This software is made available AS IS, and XEROX CORPORATION DISCLAIMS
;; ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
;; PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
;; LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
;; EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
;; NEGLIGENCE) OR STRICT LIABILITY, EVEN IF XEROX CORPORATION IS ADVISED
;; OF THE POSSIBILITY OF SUCH DAMAGES.
;; **********************************************************************

;;; Internal Instance Management

;; First, define some bindings that will be set in a moment
(define %allocate-instance-internal nil)
(define %instance? nil)
(define %instance-class nil)
(define %instance-name nil)
(define %instance-ref nil)
(define %instance-set! nil)
(define %set-instance-class-to-self nil)
(define %set-instance-func! nil)

;; This is nasty, but necessary because Mesche doesn't have errors yet!
(define (error message)
  (display "\nERROR: ")
  (display message)
  (display "\n")

  ;; Invoke a runtime error to stop execution
  (car "ERROR"))

;; TODO: Remove this!
(define (print object)
  (let ((name (%instance-name object)))
    (if name
        (begin
          (display "<")
          (display name)
          (display ">"))
        (if (pair? object)
            (begin
              (display "(")
              (print (car object))
              (if (pair? (cdr object))
                  (begin
                    (display " ")
                    (print (cdr object)))
                  (if (not (null? (cdr object)))
                      (begin
                        (display " . ")
                        (print (cdr object)))))
              (display ")"))
            (if (null? object)
                (display "'()")
                (display object))))))

(define (debug message value)
  (display message)
  (print value)
  (display "\n")
  value)

;; NOTE: I have to do it this way because I don't have letrec yet.  However,
;; once I have macros I will implement a better approach which doesn't use this
;; inefficient instance lookup pattern (or the separate <entity-class>).

(let ((instances '())
      (get-instance nil))

  (set! get-instance
        (lambda (closure)
          (let ((entry (assq closure instances)))
            (if entry (cdr entry) nil))))

  (set! %allocate-instance-internal
        (lambda (class name lock func num-fields)
          ;; Create an array for the instance and stash the class at the front
          ;; (display "ALLOCATE INSTANCE WITH FIELDS ")
          ;; (display num-fields)
          ;; (display "\n")
          (let ((instance (make-array (+ num-fields 4))))
            ;; Create the closure function that can be used to invoke the
            ;; instance (in the case of generic methods)
            (let ((closure (lambda (:rest args)
                             ;; (display "INVOKING CLOSURE FUNCTION, ARGS: ")
                             ;; (print args)
                             ;; (display "\n")
                             (apply (array-nth instance 0) args))))

              ;; Set the 4 most important fields for tracking instances
              (array-nth-set! instance 0 func)
              (array-nth-set! instance 1 lock)
              (array-nth-set! instance 2 class)
              (array-nth-set! instance 3 name)

              ;; Add the instance to the internal list for lookup later
              (set! instances (cons (cons closure instance) instances))

              ;; Return the new closure because it identifies the instance
              closure))))

  (set! %instance?
        (lambda (closure)
          (not (null? (get-instance closure)))))

  (set! %instance-class
        (lambda (closure)
          (let ((instance (get-instance closure)))
            (array-nth instance 2))))

  (set! %instance-name
        (lambda (closure)
          (let ((instance (get-instance closure)))
            (if instance
                (array-nth instance 3)))))

  (set! %set-instance-class-to-self
        (lambda (closure)
          (let ((instance (get-instance closure)))
            (array-nth-set! instance 2 closure))))

  (set! %set-instance-func!
        (lambda (closure func)
          ;; Make sure this isn't a class instance already
          (let ((instance (get-instance closure)))
            (debug "SETTING INSTANCE FUNC FOR: " (array-nth instance 3))
            ;; (display "\n")
            (if (array-nth instance 1)
                (error "Can't set function of existing class instance.")
                (array-nth-set! instance 0 func)))))

  ;; TODO: Pre-calculate the index so that it's not necessary to do an addition
  ;; for every ref.

  (set! %instance-ref
        (lambda (closure field-index)
          (let ((instance (get-instance closure)))
            (array-nth instance (+ field-index 4)))))

  (set! %instance-set!
        (lambda (closure field-index new-value)
          (let ((instance (get-instance closure)))
            (array-nth-set! instance (+ field-index 4) new-value)))))

(define (class-of object) :export
  (let ((maybe-class (%instance-class object)))
    ;; TODO: Use cond for this when I have it
    ;; TODO: Predicates missing:
    (if maybe-class
        maybe-class
        (if (string? object)
            <string>
            (if (function? object)
                <function>
                (if (number? object)
                    <number>
                    (if (boolean? object)
                        <boolean>
                        (if (pair? object)
                            <pair>
                            (if (array? object)
                                <array>
                                (if (null? object)
                                    <null>
                                    (if (symbol? object)
                                        <symbol>
                                        (if (keyword? object)
                                            <keyword>
                                            nil))))))))))))

(define (field-find class field-name)
  (let ((accessors (if (eqv? class <class>)
                       class-field-accessors
                       (field-ref class 'field-accessors))))
    (let ((accessor (assq field-name accessors)))
      (if accessor
          (cdr accessor)
          (begin
            ;; TODO: Throw an error here
            (display "FIELD ACCESSORS NOT FOUND: ")
            (display field-name)
            (display "\n")
            nil)))))

(define (field-set! object field-name value) :export
  (let ((accessor (field-find (class-of object) field-name)))
    (if (pair? accessor)
        ((car (cdr accessor)) object value)
        (error (string-append "Field setter for '"
                              (symbol->string field-name)
                              "' not found.")))))

(define (field-ref object field-name) :export
  (let ((accessor (field-find (class-of object) field-name)))
    (if (pair? accessor)
        ((car accessor) object)
        (error (string-append "Field getter for '"
                              (symbol->string field-name)
                              "' not found.")))))

(define (%allocate-instance class name num-fields)
  (%allocate-instance-internal
   class
   name
   t
   (lambda (:rest args)
     (error "An instance isn't a function -- can't apply it."))
   num-fields))

(define (%allocate-entity class name num-fields)
  (%allocate-instance-internal
   class
   name
   nil
   (lambda (:rest args)
     (error "Tried to call an entity before its proc is set."))
   num-fields))

(define class-standard-fields
  '(direct-parents
    precedence
    direct-fields
    all-fields
    num-fields
    field-initializers
    field-accessors))

(define class-field-accessors
  (map-index (lambda (field-name index)
               ;; Generate the getter and setter for this field
               (list field-name
                     (lambda (instance)
                       (%instance-ref instance index))
                     (lambda (instance value)
                       (%instance-set! instance index value))))
             class-standard-fields))

;; Define the core class instance
(define <class> (%allocate-instance nil '<class> (length class-standard-fields)) :export)

;; Ultimately this function should be generic, but initially define it so that
;; it can be used for bootstrapping purposes
(define (make class name :rest init-args) :export
  ;; NOTE: This definition is being exported, but the real `make` function that
  ;; gets assigned toward the end of this file is what will really be exported.
  (if (or (eqv? class <class>)
          (eqv? class <entity-class>))
      ;; Make a class instance using the fields
      (let ((instance (%allocate-instance class
                                          name
                                          (length class-standard-fields)))
            (direct-parents (or (plist-ref init-args 'direct-parents) '()))
            (direct-fields (map (lambda (f)
                                  (list f))
                                (or (plist-ref init-args 'direct-fields) '())))
            (precedence '())
            (num-fields 0)
            (all-fields '())
            (field-initializers '())
            (field-allocator nil)
            (field-accessors '()))

        ;; Calculate the class precedence list
        (set! precedence
              (let loop ((parents direct-parents)
                         (result (list instance)))
                (if (pair? parents)
                    (loop (class-direct-parents (car parents))
                          (cons (car parents) result))
                    (reverse result))))

        ;; Calculate the class fields by appending the fields of all parent
        ;; classes to the direct fields of this class
        (set! all-fields
              (apply append
                     (cons direct-fields
                           (map class-direct-fields
                                (cdr precedence)))))

        ;; The field-allocator helps with setting up field initializers
        (set! field-allocator
              (lambda (field-initializer)
                (let ((index num-fields))
                  ;; Increment the field count and set up the initializer for
                  ;; this field
                  (set! num-fields (+ index 1))
                  (set! field-initializers
                        (cons field-initializer
                              field-initializers))

                  ;; Generate the getter and setter for this field
                  (list (lambda (instance)
                          (%instance-ref instance index))
                        (lambda (instance value)
                          (%instance-set! instance index value))))))

        ;; The accessor generation loop also drives the
        ;; counting of fields and creation of field
        ;; initializers
        (set! field-accessors
              (map (lambda (field)
                     (cons (car field)
                           (field-allocator (lambda () nil))))
                   all-fields))

        ;; Set the fields of the class definition
        (field-set! instance 'direct-fields direct-fields)
        (field-set! instance 'all-fields all-fields)
        (field-set! instance 'num-fields num-fields)
        (field-set! instance 'direct-parents direct-parents)
        (field-set! instance 'precedence precedence)
        (field-set! instance 'field-initializers (reverse field-initializers))
        (field-set! instance 'field-accessors field-accessors)

        ;; Return the finished instance
        instance)

      ;; TODO: Initialize other core types
      (if (eqv? class <generic>)
          (let ((generic (%allocate-entity class
                                           name
                                           (length (class-fields class)))))
            ;; Set the method list and return the new generic instance
            (field-set! generic 'methods '())
            generic)
          (if (eqv? class <method>)
              (let ((method (%allocate-instance class
                                                nil
                                                (length (class-fields class)))))
                ;; Set the method details and return the new instance
                (field-set! method 'signature (plist-ref init-args 'signature))
                (field-set! method 'function (plist-ref init-args 'function))
                method)))))

(define (class-direct-fields class) :export
  (or (field-ref class 'direct-fields) '()))

(define (class-direct-parents class) :export
  (or (field-ref class 'direct-parents) '()))

(define (class-fields class) :export
  (or (field-ref class 'all-fields) '()))

(define (class-precedence class) :export
  (debug "CPL: " (or (field-ref class 'precedence) '())))

(define (generic-methods generic)
  (field-ref generic 'methods))

(define (method-signature method)
  (field-ref method 'signature))

(define (method-function method)
  (field-ref method 'function))

;; Initialize <top> and <object> *before* we finish initializing <class> so that
;; they don't pick up any of the fields of its definition.

;; The top of the class hierarchy
(define <top>
  (make <class> '<top>
    'direct-fields '()
    'direct-parents '()) :export)

;; The top of the class instance hierarchy
(define <object>
  (make <class> '<object>
    'direct-fields '()
    'direct-parents (list <top>)) :export)

;; Set the <class>'s class type to itself
(%set-instance-class-to-self <class>)

;; Finish the definition of <class>
(field-set! <class> 'precedence (list <class> <object> <top>))
(field-set! <class> 'direct-parents (list <object>))

;; Put fields in the format the protocol expects, a list starting with the field
;; name
(field-set! <class> 'direct-fields (map (lambda (f)
                                          (list f))
                                        class-standard-fields))
(field-set! <class> 'all-fields (map (lambda (f)
                                          (list f))
                                        class-standard-fields))
(field-set! <class> 'num-fields (length class-standard-fields))

(define <procedure-class>
  (make <class> '<procedure-class>
		'direct-parents (list <class>)
		'direct-fields  (list)) :export)

(define <entity-class>
  (make <class> '<entity-class>
    'direct-parents (list <procedure-class>)
    'direct-fields (list)) :export)

(define <generic>
  (make <entity-class> '<generic>
		'direct-parents (list <object>)
		'direct-fields  (list 'methods)) :export)

(define <method>
  (make <class> '<method>
    'direct-parents (list <object>)
    'direct-fields '(signature function)) :export)

(define <primitive-class>
  (make <class> '<primitive-class>
    'direct-parents (list <class>)
    'direct-fields '()) :export)

;; Defines a class with no information, just used as a sentinel
(define (make-primitive-class name :rest class) :export
  (make (if (not class) <primitive-class> (car class))
    name
    'direct-parents (list <top>)
    'direct-fields '()))

(define <pair> (make-primitive-class '<pair>) :export)
(define <null> (make-primitive-class '<null>) :export)
(define <string> (make-primitive-class '<string>) :export)
(define <number> (make-primitive-class '<number>) :export)
(define <boolean> (make-primitive-class '<boolean>) :export)
(define <array> (make-primitive-class '<array>) :export)
(define <symbol> (make-primitive-class '<symbol>) :export)
(define <keyword> (make-primitive-class '<keyword>) :export)
(define <function> (make-primitive-class '<function> <procedure-class>) :export)

;;; Helper methods

(define (make-generic name)
  (make <generic> name))

(define (make-class name direct-parents direct-fields)
  (make <class> name
    'direct-parents direct-parents
    'direct-fields direct-fields))

(define (make-method signature function)
  (make <method> nil
    'signature signature
    'function function))

;;; Initialize the Protocol

;; Core Initialization

(define initialize (make-generic 'initialize))

;; Instance Allocation and Access

(define allocate-instance (make-generic 'allocate-instance))
(define compute-accessors (make-generic 'compute-accessors))

;; Class Initialization

(define compute-class-precedence-list (make-generic 'compute-class-precedence-list))
(define compute-fields (make-generic 'compute-fields))

;; Generic Invocation

;; Produces a closure that will invoke the generic's appropriate method for an
;; argument list.
(define compute-apply-generic (make-generic 'compute-apply-generic))

;; Produces a closure that computes a list of a generic's methods that apply to
;; an argument list.
(define compute-methods (make-generic 'compute-methods))

;; A predicate used to sort the calculated method list so that more specific
;; methods are placed earlier in the list
(define compute-method-more-specific? (make-generic 'compute-method-more-specific?))

;; Produces a closure that applies the list of methods calculated by
;; `compute-methods` to an argument list.
(define compute-apply-methods (make-generic 'compute-apply-methods))

;;; Bootstrap Generic Invocation

(define generic-invocation-generics
  (list compute-apply-generic
        compute-methods
        compute-method-more-specific?
        compute-apply-methods))

(define (every test :rest lists)
  (let loop ((tails lists))
    ;; Loop until the test fails or one of the lists is exhausted
    (if (memq t (map null? tails))
        t
        (and (apply test (map car tails))
             (loop (map cdr tails))))))

;;; Method Protocol Implementation

(define (add-method! generic method)
  (let ((signature (method-signature method)))
    (debug "\nADDING METHOD TO " generic)

    (field-set! generic
                'methods
                ;; Add the method to the list while removing any equivalent method
                (debug "METHODS AFTER FILTER: "
                       (cons method
                             (filter (lambda (m)
                                       (display "COMPARING SIGNATURES:\n")
                                       (debug "  - " signature)
                                       (debug "  - " (method-signature m))
                                       (debug "  -> " (not (every (lambda (a b) (eqv? a b))
                                                                  (method-signature m)
                                                                  signature))))
                                     (field-ref generic 'methods)))))

    ;; Set the core function for the generic
    (%set-instance-func! generic (compute-apply-generic generic))

    (debug "FINISHED ADDING METHOD FOR " generic)
    (debug "NEW METHOD LIST: " (field-ref generic 'methods))
    (display "\n")
    ))

;; `compute-apply-generic` needs to be bootstrapped because all other generic
;; method behavior depends on its ability to return the new instance func for
;; the generic method.
;;
;; This function will get replaced immediately after by the `add-method!` call
;; to add the first real implementation to `compute-apply-generic`.
(%set-instance-func! compute-apply-generic
                     (lambda (generic)
                       ;; This effectively finds the first method of
                       ;; `compute-apply-generic`, added below, causing it to be
                       ;; invoked on itself!
                       (let ((method (car (generic-methods generic))))
                         ((method-function method) nil generic))))

;; TODO: Should this move to (mesche core)?
(define (last list)
  (if (null? list)
      nil
      (if (null? (cdr list))
          (car list)
          (last (cdr list)))))

;; Add the concrete implementation of `compute-apply-generic` specialized to the
;; <generic> type.  This will end up invoking the bootstrapped
;; `compute-apply-generic` function registered above only to replace it with
;; its own result!
(add-method! compute-apply-generic
             (make-method (list <generic>)
              (lambda (call-next-method generic)
                (lambda (:rest args)
                  ;; This predicate checks to see if the generic function itself
                  ;; is a member of the `generic-invocation-generics` list,
                  ;; meaning it's one of the generic protocol methods.  It also
                  ;; checks if the first (sole?)  argument is also a member of
                  ;; this list.
                  ;;
                  ;; In other words, if the generic protocol is working on
                  ;; itself, invoke the method differently.
                  (if (and (memq generic generic-invocation-generics)
                           (memq (car args) generic-invocation-generics))
                      ;; Shortcut to invocation of a generic protocol method on
                      ;; another generic protocol method
                      (apply (method-function (last (generic-methods generic)))
                             (cons nil args))
                      ;; Compute the method invoker for the generic with respect
                      ;; to the argument list and invoke it immediately
                      (begin
                        (debug "* DISPATCH GENERIC METHOD " generic)
                        (debug "  -> ARGS: " args)
                        ((compute-apply-methods generic)
                         ((compute-methods generic) args)
                         args)))))))


(define (applicable? class argument)
  ;; Is the specified class in the precedence list of the argument?
  (memq class (class-precedence (class-of argument))))

(define (more-specific? class1 class2 argument)
  ;; Use memq to find whether class2 comes before class1 in the class
  ;; precedence list.  This works because memq will return the remaining
  ;; list after class1 is found, so if class 2 is found in that remaining
  ;; list, it is a parent class of class1.
  (memq class2 (memq class1 (class-precedence (class-of argument)))))

(add-method! compute-methods
             (make-method (list <generic>)
              (lambda (call-next-method generic)
                (lambda (args)
                  ;; (debug "COMPUTE METHODS FOR " generic)
                  ;; (debug "  -> ARGS: " args)
                  ;; First, come up with a list of applicable methods by
                  ;; filtering the method list down to those with a specializer
                  ;; list that is applicable to each of the arguments.
                  (let ((applicable-methods
                         (filter (lambda (method)
                                   ;; Use applicable? on each specializer versus
                                   ;; each argument
                                   (every applicable?
                                          (method-signature method)
                                          args))
                                 (generic-methods generic))))
                    ;; Now sort the applicable list from most specific to least
                    ;; specific to produce the appropriate call ordering.
                    (debug "  APPLICABLE METHODS: "
                           applicable-methods)
                    ;; (sort (lambda (method1 method2)
                    ;;         ((compute-method-more-specific? generic)
                    ;;          method1
                    ;;          method2
                    ;;          args))
                    ;;       applicable-methods)
                    )))))

(add-method! compute-method-more-specific?
             (make-method
              (list <generic>)
              (lambda (call-next-method generic)
                (lambda (method1 method2 args)
                  (let loop ((specs1 (method-signature method1))
                             (specs2 (method-signature method2))
                             (args args))
                    ;; TODO: Use cond here!
                    (if (and (null? specs1)
                             (null? specs2))
                        (error "Two methods are equally specific.")
                        (if (or (null? specs1) (null? specs2))
                            (error "Two methods have a different number of signature types.")
                            (if (null? args)
                                (error "Fewer arguments than signature.")
                                (let ((class1 (car specs1))
                                      (class2 (car specs2))
                                      (arg (car args)))
                                  (if (eqv? class1 class2)
                                      (loop (cdr specs1)
                                            (cdr specs2)
                                            (cdr args))
                                      ;; If we've reached this point, class1 and
                                      ;; class2 are not the same so check if
                                      ;; class1 is more specific than class2.
                                      (more-specific? class1 class2 arg)))))))))))

(add-method! compute-apply-methods
             (make-method (list <generic>)
              (lambda (call-next-method generic)
                (lambda (methods args)
                  (debug "! DISPATCH METHODS FOR GENERIC: " generic)
                  (debug "  -> METHODS: " methods)
                  (debug "  -> ARGS: " args)
                  ;; TODO: Use letrec to simplify this
                  (let ((next-method nil))
                    (set! next-method
                          (lambda (tail)
                            (lambda ()
                              (if (null? tail)
                                  (error "No applicable methods/next methods.\n")
                                  (apply (method-function (car tail))
                                         (cons (next-method (cdr tail)) args))))))

                    ;; Call the first method in the list
                    ((next-method methods)))))))

;;; Instance Protocol Implementation

(display "\nADDING OBJECT INITIALIZER\n")

;; <object> types require no explicit initialization
(add-method! initialize
             (make-method (list <object>)
                          (lambda (call-next-method object init-args) object)))

(display "\nADDING CLASS INITIALIZER\n")

;; Here is where we re-define the behavior of the bootstrapped `make`!
(add-method! initialize
             (make-method (list <class>)
                          (lambda (call-next-method class init-args)
                            ;; First, call the next method in case there is any
                            ;; additional initialization
                            (call-next-method)

                            ;; Set the direct parents based on the init
                            ;; parameter
                            (field-set! class
                                        'direct-parents
                                        (or (plist-ref init-args 'direct-parents) '()))

                            (debug "DIRECT PARENTS: " (field-ref class 'direct-parents))

                            ;; Set up the direct class fields based on the init
                            ;; parameter
                            (field-set! class
                                        'direct-fields
                                        (map (lambda (field)
                                               ;; Make sure all fields can be treated as lists
                                               (if (pair? field)
                                                   field
                                                   (list field)))
                                             (or (plist-ref init-args 'direct-fields) '())))

                            ;; Compute the class precedence list
                            (field-set! class
                                        'precedence
                                        (compute-class-precedence-list class))

                            ;; Compute the full field list
                            (field-set! class
                                        'all-fields
                                        (compute-fields class))

                            ;; Generate the field initializers and accessors
                            (let ((num-fields 0)
                                  (field-initializers '())
                                  (field-allocator nil)
                                  (field-accessors nil))
                              (set! field-allocator
                                    (lambda (field-initializer)
                                      (lambda (field-name index)
                                        ;; Increment the field count and set up
                                        ;; the initializer for this field
                                        (display "CREATING FIELD ")
                                        (display field-name)
                                        (display " WITH INDEX ")
                                        (display index)
                                        (display "!\n")
                                        (set! num-fields (+ index 1))
                                        (set! field-initializers
                                              (cons field-initializer
                                                    field-initializers))

                                        ;; Generate the getter and setter for
                                        ;; this field
                                        (list (lambda (instance)
                                                (%instance-ref instance index))
                                              (lambda (instance value)
                                                (%instance-set! instance index value))))))

                              ;; The accessor generation loop also drives the
                              ;; counting of fields and creation of field
                              ;; initializers
                              (set! field-accessors
                                    (map (lambda (field)
                                           (cons (car field)
                                                 (compute-accessor class
                                                                   field
                                                                   field-allocator)))
                                         (field-ref class 'all-fields)))

                              (field-set! class 'num-fields num-fields)
                              (field-set! class 'field-initializers field-initializers)
                              (field-set! class 'field-accessors field-accessors)))))

(display "\nADDING GENERIC INITIALIZER\n")

(add-method! initialize
            (make-method (list <generic>)
                         (lambda (call-next-method generic init-args)
                           (call-next-method)
                           (field-set! generic 'methods '())
                           (%set-instance-func! generic
                                                (lambda (:rest args)
                                                  (error "Has no methods."))))))

(add-method! initialize
            (make-method (list <method>)
                         (lambda (call-next-method method init-args)
                           (call-next-method)
                           (field-set! method 'specializers (plist-ref init-args 'specializers))
                           (field-set! method 'procedure (plist-ref init-args 'procedure)))))

(display "BEFORE ALLOCATE METHOD\n")

(add-method! allocate-instance
             (make-method (list <class>)
                          (lambda (call-next-method class name)
                            (display "IN ALLOCATE INSTANCE\n")
                            ;; TODO: Use let*
                            (let ((field-initializers (field-ref class 'field-initializers))
                                  (instance nil))
                              (set! instance (%allocate-instance
                                              class
                                              name
                                              (length field-initializers)))

                              ;; Loop over all the field initializers to
                              ;; initialize the instance
                              (let loop ((index 0)
                                         (initializers field-initializers))
                                (if (pair? initializers)
                                    (begin
                                      ;; Initialize the field value by executing
                                      ;; the initializer function
                                      (%instance-set! instance index ((car initializers)))
                                      (loop (+ index 1)
                                            (cdr initializers)))

                                    ;; Return the new instance
                                    instance))))))

;; TODO: Remove code duplication

(add-method! allocate-instance
             (make-method (list <entity-class>)
                          (lambda (call-next-method class name)
                            (let ((field-initializers (field-ref class 'field-initializers))
                                  (instance nil))
                              (set! instance (%allocate-entity
                                              class
                                              name
                                              (length field-initializers)))
                              ;; Loop over all the field initializers to
                              ;; initialize the instance
                              (let loop ((index 0)
                                         (initializers field-initializers))
                                (if (pair? initializers)
                                    (begin
                                      ;; Initialize the field value by executing
                                      ;; the initializer function
                                      (%instance-set! instance index ((car initializers)))
                                      (loop (+ index 1)
                                            (cdr initializers)))

                                    ;; Return the new instance
                                    instance))))))

;; NOTE: The next few functions are copied almost verbatim from Tiny CLOS.
;; Eventually I'd like to rewrite and integrate some of them into Mesche's
;; standard library to be used elsewhere.

(define (topological-sort elements constraints tie-breaker)
  (let loop ((elements elements)
             (result '()))
    ;; Loop until the element list is exhausted
    (if (null? elements)
        result
        (let ((can-go-in-now
               ;; Filter the remaining elements list
               (filter (lambda (element)
                         ;; The element passes the filter if it's not equal to
                         ;; the head of any constraint's list or if the
                         ;; constraint itself can be found in the result.
                         ;;
                         ;; In other words, the element is a candidate to be
                         ;; inserted when it's not the subject of a constraint
                         ;; or if the constraint is already in the result list.
                         (every (lambda (constraint)
                                  (or (not (eqv? (cadr constraint) element))
                                      (memq (car constraint) result)))
                                constraints))
                       elements)))
          (if (null? can-go-in-now)
              (error "Invalid constraints")
              (let ((choice (if (null? (cdr can-go-in-now))
                                (car can-go-in-now)
                                (tie-breaker result
                                             can-go-in-now))))
                (loop (filter (lambda (x) (not (eqv? x choice)))
                              elements)
                      (append result (list choice)))))))))

(define (std-tie-breaker get-parents)
  (lambda (partial-cpl min-elts)
    (let loop ((pcpl (reverse partial-cpl)))
      (let ((current-elt (car pcpl)))
        (let ((ds-of-ce (get-parents current-elt)))
          (let ((common (collect-if (lambda (x)
                                      (memq x ds-of-ce))
                                    min-elts)))
            (if (null? common)
                (if (null? (cdr pcpl))
                    (error "Nothing valid")
                    (loop (cdr pcpl)))
                (car common))))))))

(define (build-transitive-closure get-follow-ons start-obj)
  (let track ((result '())
              (pending (list start-obj)))
    (if (null? pending)
        result
        (let ((next (car pending)))
          (if (memq next result)
              ;; If next is already in the result, skip it and continue
              (track result (cdr pending))

              ;; Otherwise, add it to the result and add its parents to the
              ;; pending list
              (track (cons next result)
                     (append (get-follow-ons next)
                             (cdr pending))))))))

(define (build-constraints get-follow-ons start-obj)
  ;; This function appears to generate a list of pairs that map a class to its
  ;; immediate parents.
  (let loop ((elements (build-transitive-closure get-follow-ons start-obj))
             (this-one '())
             (result '()))
    (if (or (null? this-one) (null? (cdr this-one)))
        (if (null? elements)
            result
            (loop (cdr elements)
                  (cons (car elements)
                        (get-follow-ons (car elements)))
                  result))
        (loop elements
              (cdr this-one)
              (cons (list (car this-one) (cadr this-one))
                    result)))))

(define (compute-standard-precedence-list class class-parents-func)
  (topological-sort (build-transitive-closure class-parents-func class)
                     (build-constraints class-parents-func class)
                     (std-tie-breaker class-parents-func)))

(add-method! compute-class-precedence-list
             (make-method (list <class>)
                          (lambda (call-next-method class)
                            (compute-standard-precedence-list class class-direct-parents))))

(add-method! compute-fields
             (make-method (list <class>)
                          (lambda (call-next-method class)
                            (display "COMPUTING FIELDS!\n")
                            (let collect ((fields (apply append
                                                         (debug "FIELDS: " (map class-direct-fields
                                                                                (class-precedence class)))))
                                          (result '()))
                              (if (null? fields)
                                  (reverse result)
                                  ;; TODO: Use let*
                                  (let ((current (car fields))
                                        (name nil)
                                        (others '())
                                        (remaining-fields nil))

                                    (set! name (car current))
                                    (set! remaining-fields
                                          (filter (lambda (o)
                                                    (if (eq? (car o) name)
                                                        (begin
                                                          (set! others (cons o others))
                                                          nil)
                                                        t))
                                                  (cdr fields)))

                                    (collect remaining-fields
                                             (cons (append current
                                                           (apply append (map cdr others)))
                                                   result))))))))


(add-method! compute-accessors
             (make-method (list <class>)
                          (lambda (call-next-method class field field-allocator)
                            ;; TODO: How do I deal with default values?
                            (field-allocator (lambda () '())))))

;; To finish off the bootstrapping process, replace the bootstrapping `make`
;; with one that invokes the real metaobject protocol!

(set! make
      (lambda (class name :rest init-args)
        ;; This function merely allocates an instance for the specified class
        ;; and then initializes it based on the init-args.  The generic
        ;; initialization protocol takes care of the rest!
        (display "\nIN THE NEW MAKE!\n")
        (let ((instance (allocate-instance class name)))
          (initialize instance init-args)
          instance)))
